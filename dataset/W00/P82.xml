<?xml version="1.0" encoding="UTF-8"?>
	<volume id="P82">

		<paper id="1004">
			<definition id="0">
				<sentence>For the purposes of this paper , we can consider aa~ t~ase facts to be atomic formulae ( i.e. , they contain no logical operators except negation ) .</sentence>
				<definiendum id="0">atomic formulae</definiendum>
				<definiens id="0">they contain no logical operators except negation )</definiens>
			</definition>
			<definition id="1">
				<sentence>Objects include all conceivable physical objects as well as abstract objects such as ideas , numbers , etc .</sentence>
				<definiendum id="0">Objects</definiendum>
			</definition>
			<definition id="2">
				<sentence>Fact ( 29 ) , given ( 27 ) and ( 28 ) , is equivalent to ( 30 ) v a : ACTIONS ( ROLE a ACTOR JACK ) • -- , VIOLENT ( a ) .</sentence>
				<definiendum id="0">VIOLENT</definiendum>
				<definiens id="0">equivalent to ( 30 ) v a : ACTIONS ( ROLE a ACTOR JACK ) • --</definiens>
			</definition>
			<definition id="3">
				<sentence>In general , a formula of the form v a : T \ [ R1V1\ ] ... \ [ RnVn\ ] Pa is equivalent to v a ( TYPE ( a , T ) A ROLE ( a , R1 , V1 ) A ... A ROLE ( a , Rn , Vn ) ) • -* Pa. 23 Correspondingly , an existentially cluantitied formula such as 3 a : T \ [ R1V1\ ] ... \ [ RnVn\ ] Pa is equivalent to 3 a TYPE ( a , T ) A ROLE ( a , R1 , V1 ) A ... ^ ROLE ( a , Rn , V n ) ^ Pa .</sentence>
				<definiendum id="0">TYPE</definiendum>
				<definiendum id="1">ROLE</definiendum>
				<definiendum id="2">ROLE</definiendum>
				<definiendum id="3">ROLE</definiendum>
			</definition>
			<definition id="4">
				<sentence>Thus we need ( A.6 ) v il , i2 , t ( DTYPE ( il , t ) A DTYPE ( i2 , t ) A ~ IDENTICAL ( il , i2 ) ) • -- , ( i 1 * i 2 ) ( A.7 ) vi , t DTYPE ( i , t ) -- - , TYPE ( i , t ) Another extremely useful categorization of objects is the partitioning of a type into a set of subtypes , i.e. , each element of the type is a member of exactly one subtype .</sentence>
				<definiendum id="0">DTYPE</definiendum>
				<definiendum id="1">DTYPE</definiendum>
			</definition>
			<definition id="5">
				<sentence>24 For example , consider the type AGE-RELS of age properties , which takes two roles , an OBJECT and a VALUE .</sentence>
				<definiendum id="0">OBJECT</definiendum>
				<definiens id="0">takes two roles , an</definiens>
			</definition>
</paper>

		<paper id="1012">
			<definition id="0">
				<sentence>I INTRODUCTION I shall discuss issues in natural language ( NL ) access to databases in the light of an experimental NL questlon-answering system , Chat , which I wrote with Fernando Perelra at Edinburgh University , and which is described more fully elsewhere \ [ 8\ ] \ [ 6\ ] \ [ 5\ ] .</sentence>
				<definiendum id="0">Chat</definiendum>
				<definiens id="0">discuss issues in natural language ( NL ) access to databases in the light of an experimental NL questlon-answering system ,</definiens>
			</definition>
			<definition id="1">
				<sentence>says that the length of a ship is the length of that ship 's class .</sentence>
				<definiendum id="0">length of a ship</definiendum>
				<definiens id="0">the length of that ship 's class</definiens>
			</definition>
			<definition id="2">
				<sentence>III A FURTHER ISSUE SEMANTICS OF PLURAL `` THE '' A difficulty we experienced in developing Chat , which I would propose as one of the most pressing problems in NL access to databases , is to define an adequate theoretical and computational semantics for plural noun phrases , especially those with the definite article `` the '' .</sentence>
				<definiendum id="0">FURTHER ISSUE SEMANTICS OF PLURAL</definiendum>
				<definiens id="0">to define an adequate theoretical and computational semantics for plural noun phrases</definiens>
			</definition>
			<definition id="3">
				<sentence>gets as part of its translation : borders ( S , atlantlc ) where S is the set of European countries .</sentence>
				<definiendum id="0">S</definiendum>
				<definiens id="0">the set of European countries</definiens>
			</definition>
</paper>

		<paper id="1005">
</paper>

		<paper id="1029">
			<definition id="0">
				<sentence>The ENHANCE system creates part of the knowledge representation used by TEXT based on the contents of the database .</sentence>
				<definiendum id="0">ENHANCE system</definiendum>
				<definiens id="0">creates part of the knowledge representation used by TEXT based on the contents of the database</definiens>
			</definition>
			<definition id="1">
				<sentence>Of these , TEXT uses a generalization hierarch Z on the entities in order to define or identify them in terms of ( I ) their constituents ( e.g. `` There are two types of entities in the ONR database : destructive devices and vehicles . ''</sentence>
				<definiendum id="0">TEXT</definiendum>
				<definiens id="0">uses a generalization hierarch Z on the entities in order to define or identify them in terms of ( I ) their constituents</definiens>
			</definition>
			<definition id="2">
				<sentence>The ENHANCE system consists of ~ set of independent modules ; each is responsible for generating some piece of descriptive information for the sub-classes .</sentence>
				<definiendum id="0">ENHANCE system</definiendum>
			</definition>
			<definition id="3">
				<sentence>The Distinguishing Descriptive Attributes ( DDAs ) of a sub-class is a set of attributes , other than the based DB attribute , whose collective value differentiates that sub-class from all other sub-classes in the same breakdown .</sentence>
				<definiendum id="0">Distinguishing Descriptive Attributes ( DDAs ) of a sub-class</definiendum>
				<definiens id="0">a set of attributes , other than the based DB attribute , whose collective value differentiates that sub-class from all other sub-classes in the same breakdown</definiens>
			</definition>
			<definition id="4">
				<sentence>Finding the DDA of a sub-class is a problem which is ccmbinatoric in nature since it may require looking at all combinations of the attributes of the entity class .</sentence>
				<definiendum id="0">Finding the DDA of a sub-class</definiendum>
				<definiens id="0">a problem which is ccmbinatoric in nature since it may require looking at all combinations of the attributes of the entity class</definiens>
			</definition>
</paper>

		<paper id="1024">
</paper>

		<paper id="1016">
			<definition id="0">
				<sentence>We are testing our heuristic using the RUS grammar ( Bebrow , 1978 ) which has frequent calls from the grammar requesting that the semantic component decide whether to build a semantic interpretation for the partial parse found or to veto that partial parse .</sentence>
				<definiendum id="0">RUS grammar</definiendum>
			</definition>
</paper>

		<paper id="1011">
</paper>

		<paper id="1002">
</paper>

		<paper id="1015">
			<definition id="0">
				<sentence>The EPISTLE System In its current form , the EPISTLE system ( Miller , Heidorn and Jensen 1981 ) is intended to do critiquing of a writer 's use of English in business correspondence , and can do some amount of grammar and style checking .</sentence>
				<definiendum id="0">EPISTLE system</definiendum>
				<definiens id="0">intended to do critiquing of a writer 's use of English in business correspondence , and can do some amount of grammar and style checking</definiens>
			</definition>
</paper>

		<paper id="1035">
			<definition id="0">
				<sentence>NOMAD incorporates ideas from , and builds on , earlier work on conceptual analysis ( e.g. , \ [ Riesbeck and Schank 1976\ ] , \ [ Birnbaum and Selfridge 1979\ ] ) ; situation and intention inference ( e.g. , \ [ Cullingford 1977| , \ [ Wilensky 1978\ ] ) ; and English generatlon ( e.g. \ [ Goldman 1973\ ] , \ [ McGuire 1980\ ] ) .</sentence>
				<definiendum id="0">NOMAD</definiendum>
				<definiens id="0">incorporates ideas from , and builds on , earlier work on conceptual analysis</definiens>
			</definition>
			<definition id="1">
				<sentence>`` Fired '' builds a PROPEL , and expects a subject and objects to play the conceptual roles of ACTOR ( who did the PROPELing ) , OBJECT ( what got PROPELed ) and RECIPIENT ( who got PROPELed at ) .</sentence>
				<definiendum id="0">Fired</definiendum>
				<definiendum id="1">OBJECT</definiendum>
				<definiens id="0">builds a PROPEL , and expects a subject and objects to play the conceptual roles of ACTOR</definiens>
			</definition>
			<definition id="2">
				<sentence>Solution : Use situational expectations to infer missing events .</sentence>
				<definiendum id="0">Solution</definiendum>
				<definiens id="0">Use situational expectations to infer missing events</definiens>
			</definition>
			<definition id="3">
				<sentence>However , NOMAD contains the knowledge that enemies do not give weapons , information , personnel , etc. , to each other .</sentence>
				<definiendum id="0">NOMAD</definiendum>
				<definiens id="0">contains the knowledge that enemies do not give weapons , information , personnel , etc. , to each other</definiens>
			</definition>
			<definition id="4">
				<sentence>Hence it attempts to find an alternative interpretation of the sentence , in this case finding the `` returned fire '' interpretation , which does not violate any of NOMAD 's knowledge about goals .</sentence>
				<definiendum id="0">interpretation</definiendum>
				<definiens id="0">does not violate any of NOMAD 's knowledge about goals</definiens>
			</definition>
			<definition id="5">
				<sentence>NOMAD OUTPUT : An unknown enemy ship fired on us .</sentence>
				<definiendum id="0">NOMAD OUTPUT</definiendum>
				<definiens id="0">An unknown enemy ship fired on us</definiens>
			</definition>
			<definition id="6">
				<sentence>The NOMAD system is the latest in a line of `` tolerant '' language understanders , beginning with FOUL-UP , all based on the use of knowledge of syntax , semantics and pragmatics at all stages of the understanding process to cope with errors .</sentence>
				<definiendum id="0">NOMAD system</definiendum>
				<definiens id="0">tolerant '' language understanders , beginning with FOUL-UP , all based on the use of knowledge of syntax , semantics and pragmatics at all stages of the understanding process to cope with errors</definiens>
			</definition>
</paper>

		<paper id="1021">
</paper>

		<paper id="1008">
</paper>

		<paper id="1038">
</paper>

		<paper id="1020">
</paper>

		<paper id="1034">
</paper>

		<paper id="1032">
			<definition id="0">
				<sentence>ABSTRACT AMBER is a model of first language acquisition that improves its performance through a process of error recovery .</sentence>
				<definiendum id="0">ABSTRACT AMBER</definiendum>
				<definiens id="0">a model of first language acquisition that improves its performance through a process of error recovery</definiens>
			</definition>
			<definition id="1">
				<sentence>AMBER 'S learning mechanisms account for some of the major developments observed in children 's early speech .</sentence>
				<definiendum id="0">AMBER 'S learning mechanisms</definiendum>
				<definiens id="0">some of the major developments observed in children 's early speech</definiens>
			</definition>
			<definition id="2">
				<sentence>Thus , AMBER is an example of what Waterman ( 1975 ) has called an adaptive production system , which modifies its own behavior by inserting new conditionaction rules .</sentence>
				<definiendum id="0">AMBER</definiendum>
				<definiens id="0">an example of what Waterman ( 1975 ) has called an adaptive production system , which modifies its own behavior by inserting new conditionaction rules</definiens>
			</definition>
			<definition id="3">
				<sentence>object rule is constructed : AGENTOBJECT If you want to describe event1 , and agent1 is the agent of event1 , and you have described agent1 , and object1 is the object of event1 , then describe object1 .</sentence>
				<definiendum id="0">agent1</definiendum>
				<definiendum id="1">object1</definiendum>
				<definiens id="0">the agent of event1 , and you have described agent1 , and</definiens>
			</definition>
			<definition id="4">
				<sentence>In this case , the following rule is generated : ING-1 If you have described action1 , and action1 is the action of event1 , then say ING .</sentence>
				<definiendum id="0">action1</definiendum>
				<definiens id="0">the action of event1</definiens>
			</definition>
			<definition id="5">
				<sentence>AMBER uses such conditions to control the order in which morphemes are produced .</sentence>
				<definiendum id="0">AMBER</definiendum>
				<definiens id="0">uses such conditions to control the order in which morphemes are produced</definiens>
			</definition>
			<definition id="6">
				<sentence>AMBER moves through a two .</sentence>
				<definiendum id="0">AMBER</definiendum>
				<definiens id="0">moves through a two</definiens>
			</definition>
			<definition id="7">
				<sentence>The result is a new production that is identical to the original rule , except that an additional condition has been included : IS-2 If you want to describe action1 , and action I is the action of event1 , and action1 is in the present , then say IS .</sentence>
				<definiendum id="0">action I</definiendum>
				<definiendum id="1">action1</definiendum>
				<definiens id="0">a new production that is identical to the original rule , except that an additional condition has been included : IS-2 If you want to describe action1 , and</definiens>
			</definition>
			<definition id="8">
				<sentence>Accordingly , the discrimination mechanism creates a secondvariant : IS-3 If you want to describe action1 , and action1 is the action of event1 , and action1 is in the present , and agent1 is the agent of event1 , and agent1 is singular , then say IS .</sentence>
				<definiendum id="0">discrimination mechanism</definiendum>
				<definiendum id="1">action1</definiendum>
				<definiendum id="2">action1</definiendum>
				<definiendum id="3">agent1</definiendum>
				<definiendum id="4">agent1</definiendum>
				<definiens id="0">creates a secondvariant : IS-3 If you want to describe action1 , and</definiens>
				<definiens id="1">the action of event1 , and</definiens>
				<definiens id="2">the agent of event1 , and</definiens>
			</definition>
			<definition id="9">
				<sentence>As a psychological model of early syntactic development , AMEER constitutes an improvement over previous language learning programs .</sentence>
				<definiendum id="0">AMEER</definiendum>
				<definiens id="0">constitutes an improvement over previous language learning programs</definiens>
			</definition>
			<definition id="10">
				<sentence>AMBER learns the order of content words through a two-stage process , first learning to prefer some relations ( like agent ) over others ( like action or object ) , and then learning the relative orders in which such relations should be described .</sentence>
				<definiendum id="0">AMBER</definiendum>
				<definiens id="0">learns the order of content words through a two-stage process , first learning to prefer some relations ( like agent ) over others ( like action or object )</definiens>
			</definition>
			<definition id="11">
				<sentence>In this case , one might use discrimination to generate a variant version of the start rule : If you want to describe node1 , and node2 is the object of node1 , and node3 is the agent of nodel , and you have described node3 , then describe node2 .</sentence>
				<definiendum id="0">node2</definiendum>
				<definiendum id="1">node3</definiendum>
				<definiens id="0">the object of node1 , and</definiens>
			</definition>
			<definition id="12">
				<sentence>In conclusion , AMBER provides explanations for severat important phenomena observed in children 's early speech .</sentence>
				<definiendum id="0">AMBER</definiendum>
				<definiens id="0">provides explanations for severat important phenomena observed in children 's early speech</definiens>
			</definition>
</paper>

		<paper id="1019">
</paper>

		<paper id="1007">
</paper>

		<paper id="1033">
</paper>

		<paper id="1018">
</paper>

		<paper id="1023">
</paper>

		<paper id="1013">
			<definition id="0">
				<sentence>A state of a database ( OB ) is meant to represent a state of a portion of the real world .</sentence>
				<definiendum id="0">state of a database</definiendum>
				<definiens id="0">meant to represent a state of a portion of the real world</definiens>
			</definition>
			<definition id="1">
				<sentence>`` Schedule '' really corresponds to a set of similar transactions , or perhaps some parameterized version of a DB transaction .</sentence>
				<definiendum id="0">Schedule</definiendum>
				<definiens id="0">a set of similar transactions , or perhaps some parameterized version of a DB transaction</definiens>
			</definition>
			<definition id="2">
				<sentence>Sematnic data models are systems for constructing precise descriptions of protions of the real world semantic data description ( SDD ) using terms that come from the real world rather than a particular DB system .</sentence>
				<definiendum id="0">Sematnic data models</definiendum>
				<definiens id="0">systems for constructing precise descriptions of protions of the real world semantic data description ( SDD ) using terms that come from the real world rather than a particular DB system</definiens>
			</definition>
			<definition id="3">
				<sentence>However , since USER is a system variable , the only slots left are APPT .</sentence>
				<definiendum id="0">USER</definiendum>
				<definiens id="0">a system variable</definiens>
			</definition>
			<definition id="4">
				<sentence>A guard is a boolean expression involving the entities and the database that , when satisfied , indicates the associated specialization applies .</sentence>
				<definiendum id="0">guard</definiendum>
				<definiens id="0">a boolean expression involving the entities and the database that , when satisfied , indicates the associated specialization applies</definiens>
			</definition>
			<definition id="5">
				<sentence>The discrimination mechanism in TAXIS is a limited form of guards that only allows testing for entities in classes .</sentence>
				<definiendum id="0">discrimination mechanism</definiendum>
				<definiens id="0">a limited form of guards that only allows testing for entities in classes</definiens>
			</definition>
</paper>

		<paper id="1026">
</paper>

		<paper id="1022">
</paper>

		<paper id="1028">
			<definition id="0">
				<sentence>ABSTRACT Computer-based generation of natural language requires consideration of two different types of problems : i ) determining the content and textual shape of what is to be said , and 2 ) transforming that message into English .</sentence>
				<definiendum id="0">ABSTRACT Computer-based</definiendum>
				<definiens id="0">generation of natural language requires consideration of two different types of problems : i ) determining the content and textual shape of what is to be said</definiens>
			</definition>
			<definition id="1">
				<sentence>The vehicle has DB attributes that provide information on SPEED-INDICES and TRAVEL-MEANS .</sentence>
				<definiendum id="0">DB</definiendum>
				<definiens id="0">attributes that provide information on SPEED-INDICES and TRAVEL-MEANS</definiens>
			</definition>
			<definition id="2">
				<sentence>The destructive device has DB attributes that provide information on LETHAL-INDICES .</sentence>
				<definiendum id="0">DB</definiendum>
				<definiens id="0">attributes that provide information on LETHAL-INDICES</definiens>
			</definition>
			<definition id="3">
				<sentence>A formal representation of the answer ( called a `` message '' ) is constructed by selecting propositions from the relevant knowledge pool which match the rhetorical techniques in the given set .</sentence>
				<definiendum id="0">formal representation of the answer</definiendum>
				<definiens id="0">called a `` message '' ) is constructed by selecting propositions from the relevant knowledge pool which match the rhetorical techniques in the given set</definiens>
			</definition>
			<definition id="4">
				<sentence>~he generalization hierarchy includes both generalizations of entities for which physical records exist in the database ( database entity classes ) and sub-types of these entities .</sentence>
				<definiendum id="0">~he generalization hierarchy</definiendum>
				<definiens id="0">includes both generalizations of entities for which physical records exist in the database ( database entity classes</definiens>
			</definition>
			<definition id="5">
				<sentence>115 ( definition SHIP ) Schema selected : identification i ) identification 2 ) evidence 3 ) attributive 4 ) particular-illustration I ) A ship is a water-going vehicle that travels on the surface .</sentence>
				<definiendum id="0">definition SHIP</definiendum>
				<definiendum id="1">ship</definiendum>
				<definiens id="0">a water-going vehicle that travels on the surface</definiens>
			</definition>
			<definition id="6">
				<sentence>A proposition is an instantiated predicate ; predicate arguments have been filled with values from the knowledge base .</sentence>
				<definiendum id="0">proposition</definiendum>
				<definiens id="0">an instantiated predicate ; predicate arguments have been filled with values from the knowledge base</definiens>
			</definition>
			<definition id="7">
				<sentence>TEXT uses the legal focus moves identified by Sidner by only matching schema predicates against propositions which have an argument that can be focused in satisfaction of the legal options .</sentence>
				<definiendum id="0">TEXT</definiendum>
				<definiens id="0">uses the legal focus moves identified by Sidner by only matching schema predicates against propositions which have an argument that can be focused in satisfaction of the legal options</definiens>
			</definition>
</paper>

		<paper id="1037">
			<definition id="0">
				<sentence>164 Conjunction is an extremely common and yet poorly understood phenomenon .</sentence>
				<definiendum id="0">Conjunction</definiendum>
				<definiens id="0">an extremely common and yet poorly understood phenomenon</definiens>
			</definition>
</paper>

		<paper id="1001">
			<definition id="0">
				<sentence>VP ' { the translation of the VP ) is defined to be the value of ( SAP ( SAP COMP ' TENSE ' ) V ' ) , where COMF ' is a constant k-expression and SAP is the symbolic-application operator .</sentence>
				<definiendum id="0">SAP</definiendum>
				<definiendum id="1">COMF '</definiendum>
				<definiendum id="2">SAP</definiendum>
				<definiens id="0">a constant k-expression</definiens>
				<definiens id="1">the symbolic-application operator</definiens>
			</definition>
			<definition id="1">
				<sentence>If the verb phrase `` sleeps ~ were to receive the translation &lt; ( X X ( sleep X ) ) , ~ &gt; ( i.e. , a unary predicate as head and no storage ) , then the symbolic application of the verb phrase translation to the noun phrase translation would compose the heads in the usual way and take the `` uniou '' of the storage yielding &lt; ( sleep m ) , ( k S ( some m ( and ( man m ) ( happy m ) ) S ) ) &gt; .</sentence>
				<definiendum id="0">k S</definiendum>
				<definiens id="0">a unary predicate as head and no storage ) , then the symbolic application of the verb phrase translation to the noun phrase translation would compose the heads in the usual way and take the `` uniou '' of the storage yielding &lt; ( sleep m</definiens>
			</definition>
			<definition id="2">
				<sentence>v , which operates on heads representing unary predicates rather than sentence matrices .</sentence>
				<definiendum id="0">v</definiendum>
				<definiens id="0">operates on heads representing unary predicates rather than sentence matrices</definiens>
			</definition>
			<definition id="3">
				<sentence>AGREE is one of a set of macros defined for the convenience of the grammar writer .</sentence>
				<definiendum id="0">AGREE</definiendum>
				<definiens id="0">one of a set of macros defined for the convenience of the grammar writer</definiens>
			</definition>
			<definition id="4">
				<sentence>C~ S ( some X2 Cwomu X2 ) S ) ) ~\ ] \ [ cA : ( ~x C~x ) ) ~\ ] which , after the appropriate applications are performed , yields CA : CAP ( ~Y ( persuade YX2 CPX2 ) ) ) ) .</sentence>
				<definiendum id="0">C~ S</definiendum>
				<definiens id="0">some X2 Cwomu X2 ) S ) ) ~\ ] \ [ cA : ( ~x C~x ) ) ~\ ] which , after the appropriate applications are performed</definiens>
			</definition>
			<definition id="5">
				<sentence>~b , CA S ( some X2 ( roman X2 ) S ) ) ~ After the past operator has been applied , we have &lt; A : CA T ( pant ( persumde YX2 ( goX2 ) ) ) ) . ~b , CA S ( some X2 ( ~znu X2 ) S ) ) ) At this point , the pull operator ( pull.v ) can be used to bring the quantifier out of storage , yielding 6 &lt; A : CA Y ( some ~2 ( womb \ ] \ [ 2 ) ( pant ( peramado T~ ( go Yg ) ) ) ) ) . This will ultimately result in `` a woman '' getting narrow scope. The other alternative is for the quantifier to remain in storage , to be pulled only at the full sentence level , resulting in the other scoping. In Figure 2 , we have added the translations to all the nodes of the parse tree. Nodes with the same translations as their parents were left unmarked. From examination of the S node translations , the original sentence is given the fully-scoped translations ( every X2 ( man \ ] ( 2 ) ( some Xi ( woman Xi ) ( paSt ( persuade % ,9 X ! ( go Xl ) ) ) ) ) and ( some XI ( vo~ Xl ) ( every X~2 ( nan X2 ) ( pant ( persuade X2 Xl ( go Xl ) ) ) ) ) C A Simple Question-Answering System As mentioned in Section I , we were able to demonstrate the semantic capabilities of our language system by assembling a small question-answering system. Our strategy was to first translate English into logical formulas of the type discussed in \ [ Moore , 1981\ ] , which were then postprocessed into a form suitable for a first-order deduction system. 7 ( Another possible approach would have been to translate directly into first-order logic , or to develop direct proof procedures for the non-first-order language. ) Thus , we were able to integrate all the components into a question-answering system by providing a simple control structure that accepted an input , translated it into logical form , reduced the translation to first-order logic , and then either asserted the translation in the case of declarative sentences or attempted to prove it in the case of interrogatives. ( Only yes/no questions have been implemented. ) The main point of interest is that our question-answering system was able to handle complex semantic entailments involving tense , modality , and so on -- that , moreover , it was not restricted to extensional evMuation in a data base , as with conventional questionanswering systems. For example , our system was able to handle the entailments of sentences like John could not have been persuaded to go. ( The transcript of a sample dialogue is included as Appendix C. ) 6For convenience , when a final constituent o1 ' a translation is ~ it is often not written. Thus we could have written &lt; A : ( k Y ( some ... ) ... ) &gt; in this cue .</sentence>
				<definiendum id="0">CA S</definiendum>
				<definiendum id="1">CA T ( pant</definiendum>
				<definiendum id="2">pull operator</definiendum>
				<definiens id="0">the quantifier to remain in storage , to be pulled only at the full sentence level</definiens>
				<definiens id="1">all the nodes of the parse tree. Nodes with the same translations as their parents were left unmarked. From examination of the S node translations</definiens>
			</definition>
			<definition id="6">
				<sentence>( S : &lt; A : ( pant ( persuade XI X2 ( go ~ ) ) ) . ~. ( A S ( every X1 ( nan X1 ) S ) ) ( ) ~ S ( some ~ ( veto \ ] \ [ 2 ) S ) ) &gt; , &lt; A : ( some \ ] \ [ 2 ( ~man X2 ) ( past Cpersua4e X1 Y,2 ( go Yo ) ) ) ) 0 ~. ( ~ 8 ( every Zl ( man \ ] \ [ I ) S ) ) &gt; &lt; A : ( everyX2 CnanX2 ) ( some XI ( woman X1 ) ( pant ( persuade X2 Xl ( go Y~ ) ) ) ) ) &gt; cA : ( sou Xl ( wuan X1 ) ( every \ ] \ [ 2 ( man X2 ) ( pant ( p0rsuade X2 li ( go \ ] \ [ 2 ) ) ) ) ) &gt; ( SV~ ( NP : &lt; A : Xl. ~. ( A S ( everyXl ( muXl ) S ) ) ) CDKTP : ¢~ : CA P ( ~ S ( every X ( PI ) S ) ) ) . X~ ( DDET ( DET every ) ) ) ( NDU : cA : CA X ( man X ) ) ) ( None ( Nmm ( x m~n ) ) ) ) ) ( PREDICATE : &lt; A : ( AX ( past ( persuade YX2 ( goX2 ) ) ) ) . ~b. CA S ( some X2 ( woma X2 ) S ) ) ) , &lt; X : CA X ( son X2 ( woeanX2 ) ( pant ( persuade YX2 ( goX2 ) ) ) ) ) . ( AU~P : o , : CA P CA X ( pant ( P x ) ) ) ) &gt; C'X'~ a~ , , .</sentence>
				<definiendum id="0">S</definiendum>
				<definiendum id="1">DDET</definiendum>
				<definiens id="0">muXl ) S ) ) ) CDKTP : ¢~ : CA P ( ~ S ( every X ( PI ) S ) ) ) . X~</definiens>
			</definition>
			<definition id="7">
				<sentence>LD ) ( sou wOrTS ( Imd ( permaade w0175 bill John wOlT§ ) ( go wOlTe John ) ) ) ) ) Figure 3 : Translation to LF and Reduction to FOL Appendix B ) .</sentence>
				<definiendum id="0">LD ) ( sou wOrTS</definiendum>
			</definition>
</paper>

		<paper id="1009">
			<definition id="0">
				<sentence>( BD TOTAL ( ( WH SOME ) ( THING X46 ) ) ( THE ( X3 ( BD PARKING SPACE X3 ( ( WARD I ) ( BLOCK 2 ) ) BD ) ) ) BD ) LOTINS2 - &gt; ( BD TOTAL ( ( WH SOME ) ( THING X46 ) ) ( THE ( X3 ( BD PARKING SPACE X3 ( THE ( ( LOT X48 ) ( BD LOCATED X48 ( ( WARD i ) ( BLOCK 2 ) ) BD ) ) ) BD ) ) ) BD ) Note that the lot ~nsertion transformation LOTINS2 has produced structure of the type which is more directly assigned to the input query , `` What is the total number of parking spaces in the lots which are located in ward 1 block 2 ? ''</sentence>
				<definiendum id="0">BD TOTAL ( ( WH SOME )</definiendum>
				<definiens id="0">BD ) ) ) BD ) LOTINS2 - &gt; ( BD TOTAL ( ( WH SOME ) ( THING X46 ) ) ( THE ( X3 ( BD PARKING SPACE X3 ( THE ( ( LOT X48 ) ( BD LOCATED X48 ( ( WARD i ) ( BLOCK 2 ) ) BD ) ) ) BD ) ) ) BD ) Note that the lot ~nsertion transformation LOTINS2 has produced structure of the type which is more directly assigned to the input query</definiens>
			</definition>
			<definition id="1">
				<sentence>Roughly , it denotes the set of elements X46 such that X46 is the sum of the members of the bag ( like a set , but with possible duplicate elements ) of elements X3 such that a certain set is not empty , namely the set of elements X48 such that X48 is the account number ( JACCN ) of a parcel whose number of parking spaces ( JPRK ) is X3 and whose wardblock ( WBLOCK ) is 100200 .</sentence>
				<definiendum id="0">WBLOCK</definiendum>
				<definiens id="0">the set of elements X46 such that X46 is the sum of the members of the bag ( like a set , but with possible duplicate elements ) of elements X3 such that a certain set is not empty , namely the set of elements X48 such that X48 is the account number ( JACCN ) of a parcel whose number of parking spaces</definiens>
			</definition>
			<definition id="2">
				<sentence>The expression ( RELATION 'PARCFL ' ( JPRKJACCN ) ' ( X3 X48 ) ' ( == ) ) in the above logical form denotes the proposition that the relation formed from the PARCFL relation by projecting over the attributes JPRK and JACCN contains the tuple ( X3 X48 ) .</sentence>
				<definiendum id="0">RELATION 'PARCFL</definiendum>
			</definition>
			<definition id="3">
				<sentence>The logical form is straightforwardly translated by means of a LISP program whose details we will not concern ourselves with into the SQL query : SELECT SUM ( A.JPRK ) FROM PARCFL A WHERE A.WBLOCK = '100200 ' ; The other structure ( for the sentence with PARKING LOT ) lacks the triggering feature + UNIT , and hence .</sentence>
				<definiendum id="0">SUM</definiendum>
				<definiens id="0">the sentence with PARKING LOT ) lacks the triggering feature + UNIT , and hence</definiens>
			</definition>
			<definition id="4">
				<sentence>where `` child of an alumnus '' is a fixed phrase expressing the binary relation with attributes APPLICANT ( whose values are the names of applicants ) and CHILD-0F-ALUMNUS ( whose values are either T or F ) .</sentence>
				<definiendum id="0">child of an alumnus</definiendum>
				<definiens id="0">a fixed phrase expressing the binary relation with attributes APPLICANT ( whose values are the names of applicants</definiens>
			</definition>
			<definition id="5">
				<sentence>I NP- , IDET IN~ x4 / : / \ THE NOM /SIBSUBPLAN_AREA 410 X8 LUC 910 X8 This structure represents the set of elements X4 such that X4 is the zone of an element of the set of lots X8 such that the land use code ( LUC ) of X8 is 910 and the subplanning area ( SUBPLAN_AREA ) of X8 is 410 .</sentence>
				<definiendum id="0">LUC</definiendum>
				<definiendum id="1">SUBPLAN_AREA</definiendum>
				<definiens id="0">the zone of an element of the set of lots X8 such that the land use code</definiens>
			</definition>
			<definition id="6">
				<sentence>( 2 ) Store information that permits replacing expressions involving virtual relations such as ( RELATION 'GEOBASE* ' ( SUBPLAJACCN ) ' ( '0410 XS ) ' ( == ) ) by existentially quantified expressions involving only real database relations such as : ( setx 'XIII ( and ( RELATION ' PARCFL ' ( SBLOCK JACCN ) ' ( X111 XS ) , ( = = ) ) ( RELATION ' GEOBASE ' ( SUBPLA SBLOCK ) ' ( '410 XlII ) ' ( == ) ) ) ( 3 ) Make the data base administrator ( DBA ) responsible for providing a formal query language definition of the virtual relations produced .</sentence>
				<definiendum id="0">Make</definiendum>
			</definition>
			<definition id="7">
				<sentence>We begin by observing that a logical form ( foratleast 1Xl ( setx X2 ( f X2 ) ) ( g El ) ) ( which denotes the proposition that for at least one Xl which belongs to the set of elements X2 such that f ( X2 ) is true , g ( Xl ) is true ) is equivalent to the requirement of the non-emptiness of the set ( I ) ( setx 'Xl ' ( @ nd ( f Xl ) ( g XI ) ) ) Similarly , ( forall X1 ( aetx X2 ( f X2 ) ) ( g Xl ) ) ( which denotes the proposition that for all X1 in the set of elements X2 such that f ( X2 ) is true , g ( Xl ) is true ) , is equivalent to a requirement of the emptiness of the set ( 2 ) ( setx 'XI ' ( and ( f Xl ) ( not ( g Xl ) ) ) ) Conversion of expressions with universal and existential quantifiers is then possible to expressions involving only set notation and a predicate involving the emptiness of a set .</sentence>
				<definiendum id="0">Xl</definiendum>
				<definiendum id="1">aetx X2</definiendum>
				<definiendum id="2">X2 )</definiendum>
				<definiendum id="3">g ( Xl</definiendum>
				<definiens id="0">the set of elements X2 such that f ( X2</definiens>
				<definiens id="1">the proposition that for all X1 in the set of elements X2 such that f (</definiens>
				<definiens id="2">equivalent to a requirement of the emptiness of the set ( 2 ) ( setx 'XI ' ( and ( f Xl ) ( not ( g Xl ) ) ) ) Conversion of expressions with universal and existential quantifiers is then possible to expressions involving only set notation and a predicate involving the emptiness of a set</definiens>
			</definition>
			<definition id="8">
				<sentence>Fortunately , SQL provides operators EXISTS and NOT EXISTS which take as their argument an SQL SELECT expression , the type of expression into which logical forms of the type ( setx 'XI ... ) are translated .</sentence>
				<definiendum id="0">SQL</definiendum>
				<definiens id="0">provides operators EXISTS and NOT EXISTS which take as their argument an SQL SELECT expression , the type of expression into which logical forms of the type</definiens>
			</definition>
</paper>

		<paper id="1039">
</paper>

		<paper id="1010">
			<definition id="0">
				<sentence>A relational data base specifies an interpretation of a logical language which contains for every relation R \ [ K , At , ... . An\ ] a constant K denoting a set , and n functions Al , ... , An which have the denotation of K as their domain .</sentence>
				<definiendum id="0">R</definiendum>
				<definiens id="0">A relational data base specifies an interpretation of a logical language which contains for every relation</definiens>
			</definition>
			<definition id="1">
				<sentence>58 ( % y : Count ( { x EEMPLOYEES IHAVE ( y , x ) } ) ) , where y is ranging over DEPARTMENTS , and then translates this whole expression into : # ~ .</sentence>
				<definiendum id="0">y</definiendum>
				<definiens id="0">ranging over DEPARTMENTS</definiens>
			</definition>
			<definition id="2">
				<sentence>Thus , we may define the following translation : EMPLOYEES ~ U ( for : DEPTS , apply : ( % d : ( for : INTS ( # EMP ( d ) ) , apply : ( ~ x : idemp ~ d , x &gt; ) ) ) ) ) DEPARTMENTS ~ DEPTS HAVE * ( % y : rid ( y\ [ 2\ ] ) \ [ l\ ] = y\ [ l\ ] ) where id is a functionwhich establishes a oneem -to-one correspondence between its domain and its range ( its range is disjoint with all other semantic types ) ; rid is the inverse of id ; INTS is a emp function which assigns to any integer i the set of integers j such that 0 &lt; j~i. Application of these rules to ( 2 ) yields : Count ( { x E DEPTS I Count ( { y~ U ( for : DEPTS , apply : ( % d : ( for : INTS ( # EMP ( d ) ) , apply : ( % x : id ~ d , x &gt; ) ) ) ) ) 1 rid ( y ) \ [ l\ ] = x } ) &gt; i00 } ~ mp ( 6 ) which is logically equivalent to ( 5 ) above .</sentence>
				<definiendum id="0">id</definiendum>
				<definiendum id="1">rid</definiendum>
				<definiendum id="2">INTS</definiendum>
				<definiens id="0">a emp function which assigns to any integer i the set of integers j such that 0 &lt; j~i. Application of these rules to ( 2 ) yields : Count ( { x E DEPTS I Count</definiens>
			</definition>
</paper>

		<paper id="1025">
</paper>

		<paper id="1006">
			<definition id="0">
				<sentence>Comprehension is viewed as a process dependent on the conceptual specialists ( they contain the inferential knowledge ) , the schemata or frames ( they contain the declarative knowledge ) , and a parser .</sentence>
				<definiendum id="0">Comprehension</definiendum>
				<definiens id="0">a process dependent on the conceptual specialists ( they contain the inferential knowledge ) , the schemata or frames ( they contain the declarative knowledge )</definiens>
			</definition>
			<definition id="1">
				<sentence>Hence comprehension is viewed as a process in which high level sources of knowledge ( concepts ) override lower level linguistic processes .</sentence>
				<definiendum id="0">Hence comprehension</definiendum>
				<definiens id="0">a process in which high level sources of knowledge ( concepts ) override lower level linguistic processes</definiens>
			</definition>
			<definition id="2">
				<sentence>Hence comprehension is viewed as a process in which high level sources of knowledge ( concepts ) override lower level linguistic processes .</sentence>
				<definiendum id="0">Hence comprehension</definiendum>
				<definiens id="0">a process in which high level sources of knowledge ( concepts ) override lower level linguistic processes</definiens>
			</definition>
			<definition id="3">
				<sentence>DESCR is a semantic marker used to mark all words that may form part of a noun group .</sentence>
				<definiendum id="0">DESCR</definiendum>
				<definiens id="0">a semantic marker used to mark all words that may form part of a noun group</definiens>
			</definition>
			<definition id="4">
				<sentence>Because `` an '' has the marker DESCR , SENTENCE passes control to DECLARATIVE which handles sentences starting with a nominal phrase .</sentence>
				<definiendum id="0">SENTENCE</definiendum>
				<definiens id="0">passes control to DECLARATIVE which handles sentences starting with a nominal phrase</definiens>
			</definition>
			<definition id="5">
				<sentence>ACTION-VERB parses the first object and passes it to the INPUT-SUPERVISOR .</sentence>
				<definiendum id="0">ACTION-VERB</definiendum>
				<definiens id="0">parses the first object and passes it to the INPUT-SUPERVISOR</definiens>
			</definition>
			<definition id="6">
				<sentence>DESCRIPTION comes with card from `` data cards , '' and invokes RECOGNIZE-CONCEPT .</sentence>
				<definiendum id="0">DESCRIPTION</definiendum>
				<definiens id="0">comes with card from `` data cards , '' and invokes RECOGNIZE-CONCEPT</definiens>
			</definition>
			<definition id="7">
				<sentence>ACTION-VERB parses the entire sentence without recognizing any relevant concept , except the identification of the frame that was done while processing `` a bank '' .</sentence>
				<definiendum id="0">ACTION-VERB parses</definiendum>
				<definiens id="0">the entire sentence without recognizing any relevant concept</definiens>
			</definition>
			<definition id="8">
				<sentence>ACCOUNT-SP returns control to DECLARATIVE and this , after checking that QUIT has the value T , returns control to SENTENCE .</sentence>
				<definiendum id="0">QUIT</definiendum>
				<definiens id="0">has the value T , returns control to SENTENCE</definiens>
			</definition>
			<definition id="9">
				<sentence>INPUT-SP activates the DESCRIPTIVE-VERB routine and asks it to activate the INPUT-SUPERVISOR each time an object is found .</sentence>
				<definiendum id="0">INPUT-SP</definiendum>
				<definiens id="0">activates the DESCRIPTIVE-VERB routine and asks it to activate the INPUT-SUPERVISOR each time an object is found</definiens>
			</definition>
			<definition id="10">
				<sentence>i ) `` SPEC '' is a semantic feature that stands for specification .</sentence>
				<definiendum id="0">SPEC</definiendum>
				<definiens id="0">a semantic feature that stands for specification</definiens>
			</definition>
			<definition id="11">
				<sentence>DeJong , G. Prediction and Substantiation : A New Approach to Natural Language Processing .</sentence>
				<definiendum id="0">Substantiation</definiendum>
				<definiens id="0">A New Approach to Natural Language Processing</definiens>
			</definition>
</paper>

		<paper id="1031">
			<definition id="0">
				<sentence>The NL-system consists of two logical components : a ) A facility for the input of linguistic knowledge into the semantic network in natural language. , This linguistic knowledge primarily consists of rules about NLU and a lexicon .</sentence>
				<definiendum id="0">NL-system</definiendum>
				<definiens id="0">consists of two logical components : a ) A facility for the input of linguistic knowledge into the semantic network in natural language. , This linguistic knowledge primarily consists of rules about NLU and a lexicon</definiens>
			</definition>
			<definition id="1">
				<sentence>This NL-system facility enables the user to manipulate both the syntactic and semantic aspects of surface strings .</sentence>
				<definiendum id="0">NL-system facility</definiendum>
				<definiens id="0">enables the user to manipulate both the syntactic and semantic aspects of surface strings</definiens>
			</definition>
			<definition id="2">
				<sentence>L-CAT is a term which represents the category of all lexical categories such as VERB and NOUN .</sentence>
				<definiendum id="0">L-CAT</definiendum>
				<definiens id="0">a term which represents the category of all lexical categories such as VERB and NOUN</definiens>
			</definition>
			<definition id="3">
				<sentence>LREL is a term which represents the category of relations between a string and its lexical constituents .</sentence>
				<definiendum id="0">LREL</definiendum>
				<definiens id="0">a term which represents the category of relations between a string</definiens>
			</definition>
			<definition id="4">
				<sentence>Examples of L-RELs might be MOD NOUN and HEAD NOUN ( of a NOUN NOUN PHRASE ) .</sentence>
				<definiendum id="0">MOD NOUN</definiendum>
				<definiendum id="1">HEAD NOUN (</definiendum>
			</definition>
			<definition id="5">
				<sentence>VARIABLE is a term which represents the class of identifiers which the user will use as variables in his natural language rules .</sentence>
				<definiendum id="0">VARIABLE</definiendum>
				<definiens id="0">a term which represents the class of identifiers which the user will use as variables in his natural language rules</definiens>
			</definition>
			<definition id="6">
				<sentence>Currently these relations are : a ) Word W is preceded by `` connector point '' P in a surface string ; e.g. node M3 of figure I represents that word IS is preceded by connector point M2 in the string ; b9 Lexeme L is a member of category C ; e.g. this is used to represent the concept that 'BOTTLE IS A NOUN , which was input in Section 3 ; c ) The string beginning at point Pl and ending at point P2 in a surface string is in category C ; e.g. node M53 of figure 3 represents the concept that '~ bottle '' is a GNP ; d ) Item X has the relation R to item Y ; e.g. node M75 of figure 1 represents the concept that the class of bottles is a subset of the class of containers ; e ) A class is characterized by its members participating in some relation ; e.g. the class of glass bottles is characterized by its members being made of glass ; f ) The rule structures of SNePS .</sentence>
				<definiendum id="0">b9 Lexeme L</definiendum>
				<definiendum id="1">NOUN</definiendum>
				<definiens id="0">a surface string ; e.g. node M3 of figure I represents that word IS is preceded by connector point M2 in the string ;</definiens>
				<definiens id="1">a GNP ; d ) Item X has the relation R to item Y</definiens>
				<definiens id="2">a subset of the class of containers ; e ) A class is characterized by its members participating in some relation</definiens>
			</definition>
			<definition id="7">
				<sentence>A sample rule that the user might enter is : IF A STRING CONSISTS OF A G-DETERMINER FOLLOWED BY A NOUN CALLED THE MOD-NOUN FOLLOWED BY ANOTHER NOUN CALLED THE HEAD-NOUN THEN THE STRING IS AN NNP .</sentence>
				<definiendum id="0">sample rule</definiendum>
			</definition>
			<definition id="8">
				<sentence>** IF A STRING CONSISTS OF AMASS-NOUN * THEN THE STRING IS A GNP * AND THE GNP EXPRESSES THE CONCEPT NAMED BY THE MASS-NOUN .</sentence>
				<definiendum id="0">STRING CONSISTS OF AMASS-NOUN</definiendum>
			</definition>
			<definition id="9">
				<sentence>If we examine rules 1 and 2 , for example , we find they define a GNP ( a generic noun phrase ) .</sentence>
				<definiendum id="0">GNP</definiendum>
			</definition>
			<definition id="10">
				<sentence>Rule 6 is also triggered by the addition of the instances of the consequents of rules 3 and 4 and by our previous input sentences asserting that `` A bottle is a container '' and `` Milk is a fluid '' .</sentence>
				<definiendum id="0">bottle</definiendum>
				<definiendum id="1">Milk</definiendum>
				<definiens id="0">a fluid ''</definiens>
			</definition>
			<definition id="11">
				<sentence>Since the string `` a glass bottle '' is a noun-noun phrase , glass is a subset of material , and bottle is a subset of container , a new class is created which is a subset of bottles and the characteristic of this class is to be made of glass .</sentence>
				<definiendum id="0">glass</definiendum>
				<definiendum id="1">bottle</definiendum>
				<definiens id="0">a subset of material , and</definiens>
			</definition>
			<definition id="12">
				<sentence>We plan to make use of these surface strings in future work , but for this study , we have employed a second `` expresses '' relation , which we call EXPRESS-2 , and rules of the core to &gt; &lt; lXi ) &lt; J Figure 4. Network representation of a generated surface string. 142 generate surface strings to express , semantic structures. Figure 4 illustrates the network representation of the surface string generated for node M75. The string `` A bottle '' , dominated by node M221 , is generated for node M54 of figure 3 , expressing an arbitrary member of the set of bottles. The string `` a container '' , dominated by node M223 , is generated to express the set of containers , represented by node M62 of figure 3. Finally , the surface string `` A bottle is a container '' , represented by node M226 , is established to express node M75 and the answer to the query. In general , a surface sentence is generated to EXPRESS-2 a given semantic structure by first generating strings to EXPRESS-2 the substructures of the semantic structure and by assembling these strings into a network version of a list. Thus the semantic structure is processed in a bottom-up fashion. The structure of the generated string is a phrase-structured representation utilizing FIRST and REST pointers to the sub-phrases of a string. This representation reflects the subordinate relation of a phrase to its `` parent '' phrase. The structures pointed to by the FIRST and REST arcs can be a ) another list structure with FIRST and REST pointers ; b ) a string represented by a node such as Mg0 of figure 3 with BEG , END , and CAT arcs ; or c ) a node with WORD arc to a word and an optional PRED arc to another node with PRED and WORD arcs. After the structure representing the surface string has been generated , the resulting list or tree is traversed and the leaf nodes printed as response. IX CONCLUSIONS Our goal is to design a NLU system for a linguistic theorist to use for language processing. The system 's linguistic knowledge should be available to the theorist as domain knowledge. As a result of our preliminary study of a KE approach to Natural Language Understanding , we have gained valuable experience with the basic tools and concepts of such a system. All aspects of our NL-system have , of course , undergone many revisions and refinements during development and will most likely continue to do so. During the course of our study , we have a ) developed two representations of a surface string : I ) a linear representation appropriate for input strings as shown in figure i ; and 2 ) a phrase-structured representation appropriate for generation , shown in figure 4 ; b ) designed a set of SNePS rules which are capable of analyzing the user 's natural language input rules and building the corresponding network rules ; c ) identified basic concepts essential for linguistic analysis : lexical category , phrase category , relation between a string and lexical constituent , relation between a string and substrimg , the expresses relations between syntactic structures and a semantic structures , and the concept of a variable that the user may wish to use in input rules ; d ) designed a set of SNePS rules which can analyze some simple queries and generate a response. X FUTURE DIRECTION As our system has evolved , we have striven to reduce the amount of core knowledge which is essential for the system to function. We want to enable the user to define the language processing capabilities of the system~ but a basic core of rules is essential to process the user 's initial lexicon entries and rules. One of our high priority items for the immediate future is to pursue this issue. Our objective is to develop the NL-system into a boot-strap system to the greatest degree possible. That is , with a minimal core of pre-programmed knowledge , the user will input rules and assertions to enhance the system 's capability to acquire both linguistic and nonlinguistic knowledge. In other words , the user will define his own input language for entering knowledge into the system and conversing with the system. Another topic of future investigation will be the feasibility of extending the user 's control over the system 's basic tools by enabling the user to define the network Case frames for syntactic and semantic knowledge representation. We also intend to extend the capability of the system so as to enable the user to define the syntax of questions and the nature of response. XI SUMMARY This study explores the realm of a Knowledge Engineering approach to Natural Language Understanding. A basic core of NL rules enable the NLU expert to input his natural language rules and his lexicon into the semantic network knowledge base in natural lan~uame. In this system , the rules and assertions concerning both semantic and syntactic knowledge are stored in the network and undergo interaction during the deduction processes. An example was presented to illustrate : entry of the user 's lexicon into the system ; entry of the user 's natural language rule statements 143 into the system ; the types of rule statements which the user can utilize ; how rules build conceptual structures from surface strings ; the use of knowledge for disambiguating surface structure ; the use of later information for disamhiguating an earlier , partially understood sentence ; the question-answering~generation facility of the NL-system. Proceedings of the iSth Annual Meetin~ of the Association for Computational Linguistics , pp. 97-103 , 1980. Natural Language '' , Proceedings of the National Computer Conference , AFIPS Press , Montvale , NJ ) pp. 435-440,1973.. Natural Language Processing , Algorithmics Press , New York , pp. 153-188 , 1973. Answering , Lawrence Erlbaum , Hillsdale , NJ , 1978. directional Inference , Technical Report No. 174 , Department of Computer Science , SUNY at Buffalo , 1981. Logic Grammars for Natural LanKuaKe , Technical Report No. 69A-80 , Univ. of Kentucky , rev. October , 1980 , Based Multiprocessing System '' , Conference Record of the 1980 LISP Conference , Stanford Univ. , pp. 29-37 , 1980. Clause Grammars for Language Analysis -A Survey of the Formalism and a Comparison with Augmented Transition Networks '' , Artificial IntelliKence ) pp. 231-278 , 1980. 10.Robinson ) J.J. , `` DIAGRAM , A Grammar for Dialogues '' , CACM , pp. 27-47 , January , 1982. ll.Shapiro , S.C. , `` The SNePS Semantic Network Processing System '' . In N. Findler , ed. Associative Networks The Representation and Use of Knowledge by Computers , Academic Press , New York , pp. 179a-203 , 1979. 12.Shapiro , S.C. , `` Generalized Augmented Transition Network Grammars for Generation ~ , ~pu~ Semantic Networks '' , Proceedings of the 17th Annual Meetiy_~ of the Association for Computational Linguistics , pp. 25-29 , 1979. Xll APPENDIX NL CORE GRAMMAR The following grammar is a definitive description of the language in which the user can enter linguistic statements into the semantic network. The Backus-Naur Form ( BNF ) grammar is used in this language definition. Notational conventions : Phrase in lower case letters explains the word required by the user Standard grammar metasymbols : &lt; &gt; enclose nonterminal items | for alternation \ [ \ ] enclose optional items ( ) for grouping Space represents concatenation Concatenation has priority over alternation &lt; LEX-STMT &gt; : : = ' &lt; WORD &gt; IS ( AJAN ) ( L-CAT| &lt; L-CAT-MEMBER &gt; ) &lt; RULE &gt; : := IF &lt; ANT-STMT &gt; THEN &lt; CQ-STMT &gt; &lt; ANT-STMT &gt; : : = &lt; ANT-STMT &gt; AND &lt; ANT-STMT &gt; I A STRING CONSISTS OF &lt; STR-DESCRIPTION &gt; I &lt; STMT &gt; &lt; CQ-STMT &gt; : : = &lt; CQ-STMT &gt; AND &lt; CQ-STMT &gt; | THE STRING IS &lt; G-DET &gt; &lt; STRING-NAME &gt; I THERE EXISTS A &lt; CONCEPT-WORD &gt; &lt; VAR &gt; I &lt; STMT &gt; &lt; STMT &gt; : : = &lt; CL-REF &gt; &lt; REL-REF &gt; &lt; CL-REF &gt; !</sentence>
				<definiendum id="0">relation</definiendum>
				<definiens id="0">we call EXPRESS-2 , and rules of the core to &gt; &lt; lXi ) &lt; J Figure 4. Network representation of a generated surface string. 142 generate surface strings to express , semantic structures. Figure 4 illustrates the network representation of the surface string generated for node M75. The string `` A bottle '' , dominated by node M221 , is generated for node M54 of figure 3 , expressing an arbitrary member of the set of bottles. The string `` a container '' , dominated by node M223 , is generated to express the set of containers , represented by node M62 of figure 3. Finally , the surface string `` A bottle is a container '' , represented by node M226 , is established to express node M75 and the answer to the query. In general , a surface sentence is generated to EXPRESS-2 a given semantic structure by first generating strings to EXPRESS-2 the substructures of the semantic structure and by assembling these strings into a network version of a list. Thus the semantic structure is processed in a bottom-up fashion. The structure of the generated string is a phrase-structured representation utilizing FIRST and REST pointers to the sub-phrases of a string. This representation reflects the subordinate relation of a phrase to its `` parent '' phrase. The structures pointed to by the FIRST and REST arcs can be a ) another list structure with FIRST and REST pointers ; b ) a string represented by a node such as Mg0 of figure 3 with BEG , END , and CAT arcs ; or c ) a node with WORD arc to a word and an optional PRED arc to another node with PRED and WORD arcs. After the structure representing the surface string has been generated , the resulting list or tree is traversed and the leaf nodes printed as response. IX CONCLUSIONS Our goal is to design a NLU system for a linguistic theorist to use for language processing. The system 's linguistic knowledge should be available to the theorist as domain knowledge. As a result of our preliminary study of a KE approach to Natural Language Understanding , we have gained valuable experience with the basic tools and concepts of such a system. All aspects of our NL-system have , of course , undergone many revisions and refinements during development and will most likely continue to do so. During the course of our study , we have a ) developed two representations of a surface string : I ) a linear representation appropriate for input strings as shown in figure i ; and 2 ) a phrase-structured representation appropriate for generation , shown in figure 4 ; b ) designed a set of SNePS rules which are capable of analyzing the user 's natural language input rules and building the corresponding network rules ; c ) identified basic concepts essential for linguistic analysis : lexical category , phrase category , relation between a string and lexical constituent , relation between a string and substrimg , the expresses relations between syntactic structures and a semantic structures , and the concept of a variable that the user may wish to use in input rules ; d ) designed a set of SNePS rules which can analyze some simple queries and generate a response. X FUTURE DIRECTION As our system has evolved , we have striven to reduce the amount of core knowledge which is essential for the system to function. We want to enable the user to define the language processing capabilities of the system~ but a basic core of rules is essential to process the user 's initial lexicon entries and rules. One of our high priority items for the immediate future is to pursue this issue. Our objective is to develop the NL-system into a boot-strap system to the greatest degree possible. That is , with a minimal core of pre-programmed knowledge , the user will input rules and assertions to enhance the system 's capability to acquire both linguistic and nonlinguistic knowledge. In other words , the user will define his own input language for entering knowledge into the system and conversing with the system. Another topic of future investigation will be the feasibility of extending the user 's control over the system 's basic tools by enabling the user to define the network Case frames for syntactic and semantic knowledge representation. We also intend to extend the capability of the system so as to enable the user to define the syntax of questions and the nature of response. XI SUMMARY This study explores the realm of a Knowledge Engineering approach to Natural Language Understanding. A basic core of NL rules enable the NLU expert to input his natural language rules and his lexicon into the semantic network knowledge base in natural lan~uame. In this system , the rules and assertions concerning both semantic and syntactic knowledge are stored in the network and undergo interaction during the deduction processes. An example was presented to illustrate : entry of the user 's lexicon into the system ; entry of the user 's natural language rule statements 143 into the system ; the types of rule statements which the user can utilize ; how rules build conceptual structures from surface strings ; the use of knowledge for disambiguating surface structure ; the use of later information for disamhiguating an earlier , partially understood sentence ; the question-answering~generation facility of the NL-system. Proceedings of the iSth Annual Meetin~ of the Association for Computational Linguistics , pp. 97-103 , 1980. Natural Language '' , Proceedings of the National Computer Conference , AFIPS Press , Montvale , NJ ) pp. 435-440,1973.. Natural Language Processing , Algorithmics Press , New York , pp. 153-188 , 1973. Answering , Lawrence Erlbaum , Hillsdale , NJ , 1978. directional Inference , Technical Report No. 174 , Department of Computer Science , SUNY at Buffalo , 1981. Logic Grammars for Natural LanKuaKe , Technical Report No. 69A-80 , Univ. of Kentucky , rev. October , 1980 , Based Multiprocessing System '' , Conference Record of the 1980 LISP Conference , Stanford Univ. , pp. 29-37 , 1980. Clause Grammars for Language Analysis -A Survey of the Formalism and a Comparison with Augmented Transition Networks '' , Artificial IntelliKence ) pp. 231-278 , 1980. 10.Robinson ) J.J. , `` DIAGRAM , A Grammar for Dialogues '' , CACM , pp. 27-47 , January , 1982. ll.Shapiro , S.C. , `` The SNePS Semantic Network Processing System '' . In N. Findler , ed. Associative Networks The Representation and Use of Knowledge by Computers , Academic Press , New York , pp. 179a-203 , 1979. 12.Shapiro , S.C. , `` Generalized Augmented Transition Network Grammars for Generation ~ , ~pu~ Semantic Networks '' , Proceedings of the 17th Annual Meetiy_~ of the Association for Computational Linguistics</definiens>
			</definition>
			<definition id="13">
				<sentence>THE &lt; STRING-NAME &gt; EXPRESSES &lt; CL-REF &gt; I THE &lt; STRING-NAME &gt; EXPRESSES THIS LAST PROPOS ITION I THE &lt; FUN-CHAR-WORD &gt; OF &lt; CL-REF &gt; IS TO BE &lt; FUN-CHAR-VERB &gt; &lt; CL-REF &gt; &lt; STR-DESCRIPTION &gt; : : = &lt; STR-DESCRIPTION &gt; FOLLOWED BY &lt; STR-DESCRIPTION &gt; | &lt; G-DET &gt; &lt; LEX-NAME &gt; \ [ &lt; LABEL-PHRASE &gt; \ ] | THE WORD ' &lt; LITERAL &gt; &lt; LABEL-PHRASE &gt; : :-CALLED &lt; DET &gt; &lt; LABEL &gt; &lt; LEX-NAME &gt; : := any lexical category name &lt; LABEL &gt; : := any name or label &lt; STRING-NAME &gt; : := any string category name &lt; REL-REF &gt; : := IS A ( SUBSET|MEMBER ) OF | HAS THE &lt; REL-WORD &gt; TO &lt; CL-REF &gt; : := THE &lt; CONCEPT-WORD &gt; &lt; VAR &gt; | THE CLASS NAMED BY THE &lt; NAME &gt; I a member of an L-CAT category &lt; FUN-CHAR-WORD &gt; : : = ( FUNCTION |CHARACTERISTIC ) &lt; FUN-CHAR-VERB &gt; : : = any verb &lt; NAME &gt; : := name of a string phrase or the constituent of a string phrase &lt; VAR &gt; : := any member of the category VARIABLE &lt; G-DET &gt; : : -A I AN l ANOTHER &lt; DET &gt; : : = &lt; G-DET &gt; I THE &lt; REL-WORD &gt; : :~ a member of L-CAT which should denote `` relation '' &lt; WORD &gt; : := any word 144</sentence>
				<definiendum id="0">CLASS NAMED</definiendum>
				<definiens id="0">FUNCTION |CHARACTERISTIC ) &lt; FUN-CHAR-VERB &gt; : : = any verb &lt; NAME &gt; : := name of a string phrase or the constituent of a string phrase &lt; VAR &gt; : := any member of the category VARIABLE &lt; G-DET &gt; : : -A I AN l ANOTHER &lt; DET &gt; : : = &lt; G-DET &gt; I THE &lt; REL-WORD &gt;</definiens>
			</definition>
</paper>

		<paper id="1030">
			<definition id="0">
				<sentence>Visual Salience Our theory of visual salience states that a given person looking at a given picture in a given context assigns a salience ( an ordering , rather than a numeric value ) to each object as a 130 natural and automatic part of the process of perceiving and organizing the scene .</sentence>
				<definiendum id="0">salience</definiendum>
				<definiens id="0">a numeric value ) to each object as a 130 natural and automatic part of the process of perceiving and organizing the scene</definiens>
			</definition>
			<definition id="1">
				<sentence>The rating technique is a fairly stable and consistent non-subjective measure of salience ( when averaging over a ~roup ) , and is also quite sensitive to changes in the size and centrality of objects in the scene .</sentence>
				<definiendum id="0">rating technique</definiendum>
				<definiens id="0">a fairly stable and consistent non-subjective measure of salience ( when averaging over a ~roup ) , and is also quite sensitive to changes in the size and centrality of objects in the scene</definiens>
			</definition>
			<definition id="2">
				<sentence>The Current-Item register contains the object currently in focus ( and hence the most salient object which has not previously been mentioned ) , and the Main-Item register points to the data base 's most salient object as the topic of the entire paragraph ( this register is set once at the beginning of the paragraph generation process ) .</sentence>
				<definiendum id="0">Current-Item register</definiendum>
				<definiens id="0">contains the object currently in focus</definiens>
			</definition>
			<definition id="3">
				<sentence>The packets are used for high-level rhetorical control ( i.e. introducing , elaborating , shifting-topic , concluding ) , and are turned on and off by a Paragraph Driver ( which encodes the format of descriptive paragraphs ) .</sentence>
				<definiendum id="0">Paragraph Driver</definiendum>
				<definiens id="0">encodes the format of descriptive paragraphs</definiens>
			</definition>
			<definition id="4">
				<sentence>GENARO starts with an empty message buffer and with Current-item ( in our example ) set to House , the first item in the Unused Salient Object List .</sentence>
				<definiendum id="0">GENARO</definiendum>
				<definiens id="0">starts with an empty message buffer</definiens>
			</definition>
			<definition id="5">
				<sentence>Condense notices that both Door ( the Current-Item ) and Gate ( which is somewhere `` down '' in the USOL ) have the property Red , and that the salience of Gate and of the property Color ( Gate , Red ) are above the appropriate thresholds , and so proposes that Gate be made the local focus .</sentence>
				<definiendum id="0">Condense notices</definiendum>
				<definiendum id="1">Gate</definiendum>
				<definiens id="0">the property Red , and that the salience of Gate and of the property Color ( Gate , Red ) are above the appropriate thresholds , and so proposes that Gate be made the local focus</definiens>
			</definition>
</paper>

		<paper id="1036">
</paper>

		<paper id="1027">
			<definition id="0">
				<sentence>H. KNOWLEDGE REPRESENTATION KAMP uses an intensional logic to describe facts about the world , including the knowledge of agents .</sentence>
				<definiendum id="0">H. KNOWLEDGE REPRESENTATION KAMP</definiendum>
			</definition>
			<definition id="1">
				<sentence>( 2 ) In ( 2 ) , T ( w , P ) means that the object language proposition P is true in possible world w , and K ( a , w , , w~ ) is a predicate that describes the relation between possible worlds that means that w2 is a possible alternative to w , according to a 's knowledge .</sentence>
				<definiendum id="0">P )</definiendum>
				<definiendum id="1">K</definiendum>
				<definiens id="0">means that the object language proposition P is true in possible world w</definiens>
			</definition>
			<definition id="2">
				<sentence>The second axiom needed is : Vz , w , , w2 K ( z , w , , w2 ) D VyK ( Kernel ( z , y ) , wl , w~ ) ( 3 ) Axiom ( 3 ) states that the possible worlds consistent with any agent 's knowledge is a subset of the possible worlds consistent with the kernel of that agent and any other agent .</sentence>
				<definiendum id="0">w2 K</definiendum>
				<definiens id="0">z , y ) , wl , w~ ) ( 3 ) Axiom ( 3 ) states that the possible worlds consistent with any agent 's knowledge is a subset of the possible worlds consistent with the kernel of that agent and any other agent</definiens>
			</definition>
			<definition id="3">
				<sentence>THE KAMP PLANNING SYSTEM KAMP is a multiple-agent planning system designed around a NOAH-like hierarchical planner \ [ 10\ ] .</sentence>
				<definiendum id="0">KAMP PLANNING SYSTEM KAMP</definiendum>
			</definition>
			<definition id="4">
				<sentence>If a goal needs to be satisfied , KAMP searches for actions that can achieve the goal and inserts them into the plan , along with the preconditions , which become new goals to be satisfied .</sentence>
				<definiendum id="0">KAMP</definiendum>
				<definiens id="0">become new goals to be satisfied</definiens>
			</definition>
			<definition id="5">
				<sentence>The next level consists of surface speech-acts , which are abstractions of the actions of uttering particular sentences with particular syntactic structures .</sentence>
				<definiendum id="0">next level</definiendum>
				<definiens id="0">consists of surface speech-acts , which are abstractions of the actions of uttering particular sentences with particular syntactic structures</definiens>
			</definition>
			<definition id="6">
				<sentence>The next level consists of conceptactivation actions , which entail the planning of descriptions that are mutually believed by the speaker and hearer to refer to objects in the world .</sentence>
				<definiendum id="0">next level</definiendum>
				<definiens id="0">consists of conceptactivation actions , which entail the planning of descriptions that are mutually believed by the speaker and hearer to refer to objects in the world</definiens>
			</definition>
			<definition id="7">
				<sentence>The intention-communication component is an abstraction of the speaker 's plan to communicate his intention to refer , and may be realized by a plan that includes physical and linguistic actions .</sentence>
				<definiendum id="0">intention-communication component</definiendum>
				<definiens id="0">an abstraction of the speaker 's plan to communicate his intention to refer , and may be realized by a plan that includes physical and linguistic actions</definiens>
			</definition>
			<definition id="8">
				<sentence>The surface-linguistic component consists of the realization ( in some linguistic expression ) of the intention-communication component as part of the surface speech .</sentence>
				<definiendum id="0">surface-linguistic component</definiendum>
				<definiens id="0">consists of the realization ( in some linguistic expression ) of the intention-communication component as part of the surface speech</definiens>
			</definition>
			<definition id="9">
				<sentence>The following two axiom schemata describe concept activation in KAMP 's possible worlds representation : Vwl , w2 R ( Do ( A , Cact ( B , C ) ) , w , , w2 ) D T ( w , , Want ( A , Active ( A , B , C ) ) ) A T { w2 , Active ( A , B , C ) ) ( 4 ) Vw , , w2 R ( Do ( A , Cact ( B , C ) ) , Wl , w2 ) D Vw3 K ( Kernel ( A , B ) , w2 , wa ) D 3w4 R ( Do ( A , Cact ( B , C ) ) , w4 , ws ) A ( 5 ) K ( Kernel ( A , B ) , w , , w4 ) Axiom schema ( 4 ) says that when an agent A performs a concept activation for an agent B , he must first want the object C to be active , and as a result of performing it , C becomes active with respect to A and B ; Axiom schema ( 5 ) says that after agent A performs the action , the two agents A and B mutually know that the action has been performed .</sentence>
				<definiendum id="0">w2 R ( Do</definiendum>
				<definiendum id="1">Kernel</definiendum>
				<definiendum id="2">Kernel</definiendum>
				<definiens id="0">Axiom schema ( 4 ) says that when an agent A performs a concept activation for an agent B , he must first want the object C to be active</definiens>
			</definition>
			<definition id="10">
				<sentence>A D. ( x ) ) where the Di ( z ) are the individual descriptors that comprise the description .</sentence>
				<definiendum id="0">D. ( x ) )</definiendum>
				<definiens id="0">the individual descriptors that comprise the description</definiens>
			</definition>
			<definition id="11">
				<sentence>The symbol D* denotes a similar expression , which includes all the descriptors of P conjoined with a set of predicates that describe the focus of thediscourse .</sentence>
				<definiendum id="0">symbol D*</definiendum>
				<definiens id="0">includes all the descriptors of P conjoined with a set of predicates that describe the focus of thediscourse</definiens>
			</definition>
			<definition id="12">
				<sentence>KAMP uses an axiomatization of Sidner 's focusing rules Ill\ ] to keep track of focus shifts .</sentence>
				<definiendum id="0">KAMP</definiendum>
				<definiens id="0">uses an axiomatization of Sidner 's focusing rules Ill\ ] to keep track of focus shifts</definiens>
			</definition>
</paper>

		<paper id="1017">
			<definition id="0">
				<sentence>The Finite Strin~ Newsletter continues to provide general information of interest to the membership as a special section .</sentence>
				<definiendum id="0">Finite Strin~ Newsletter</definiendum>
				<definiens id="0">continues to provide general information of interest to the membership as a special section</definiens>
			</definition>
			<definition id="1">
				<sentence>ASSOCIATION FOR MACHINE TRANSLATION AND COMPUTATIONAL LINGUISTICS ( founded 6-13-1962 ) ASSOCIATION FOR COMPUTATIONAL LINGUISTICS ( renamed 7-24-1968 ) Officers , Editors , Committees , Meetings , and Program Chairing Program Chair 1963 President Yngve Vice-President Hays Set-Treasurer Josselson Executive Rhodes Committee Garvin Members Lehmann Editor ( F8 ) Roberts Editor ( MTCL ) Nominating See Committee Oettlnger Members Lamb Annual Meeting Denver 8/25-26 ( ACM ) Yngve 1964 Hays Alt Josselson Sebeok Garvin Lehmann Roberts Yngve Yngve Oettlnger Lamb Bloomington 7/29-30 ( LSA ) Chafe 1965 1966 President Lehmann Garvin Vice-President Garvin Oettinger Set-Treasurer Josselson Josselson Executive Sebeok Sebeok Committee Hockett Hockett Members Kuno Prendergraft Editor ( FS ) Roberts Roberts ~ditor ( MTCL ) Yngve Yngve Nominating Yngve Yngve Committee Rays Rays Members Lamb Lieberman Annual Meeting New York Los Angeles 5/19-21 ffi ICCL 7/26-27 ( LSA ) Program Chair Pendergraft Kay 1967 1968 President Kuno Walker Vice-President Walker Mersel See-Treasurer Josselson Josselson Executive Satterthwalt Satterthwalt Committee Hockett Fromkln Members Pendergraft Pendergraft Editor ( FS ) Roberts Roberts Editor ( MTCL ) Yngve Yngve Assoc Editor Chapln Nominating Garvin Garvin Committee Hays Kuno Members Lieberman Lieberman Annual Meeting Atlantic City Urbana 4/21 ( SJCC ) 7/24-25 ( LSA ) Program Chair Walker Petrlck 1969 President Kay Vice-Presldent Plath Set-Treasurer Josselson Executive Satterthwalt Committee Fromkln Members Montgomery Editor ( FS ) Roberts Editor ( MTCL ) Yngve Assoc Editor Chapin Nominating Garvin Committee Kuno Members Walker Annual Meeting Boston 5113 ( sJcc ) Program Chair Fraser 1970 Plath Friedman Josselson Wall Fromkin Montgomery Roberts Yngve Chapin Kay Kuno Walker Columbus 7/22-23 ( LSA ) Wall 1971 1972 President Friedman Simmons Vice-Pres Simmons Fromkin Sec-Treas Josselson Roberts Executive Wall Wall Committee Robinson Robinson Members Montgomery Chapln Editor ( FS ) Roberts Roberts Nominating Kay Kay Committee Plath Plath Members Walker Friedman Annual Meeting Atlantic City Chapel Hill 5/17 ( SJCC ) 7/26-27 ( LSA ) Program Chair Barnes Schank Program Chair 1973 President Barnes Vice-President Woods Set-Treasurer Roberts Executive Martins Committee Robinson Members Chapin Editor ( FS ) Roberts Editor ( AJCL ) Nominating Simmons Committee Plath Members Friedman Annual Meeting Ann Arbor 8/1-2 ( LSA ) Friedman 1974 Woods Wall Roberts Martins Joshl Chapln Hays Simmons Barnes Friedman Amherst 7/26-27 ( LSA ) Nash-Webber 90 1975 1976 President Joshi Petrick Vice-Preaident Petrick Grimes Sec-Treasurer Roberts Roberts/Walker Executive Martins Diller Committee Rieger Rieger Members Nash-Webber Nash-Webber Editor ( AJCL ) Hays Hays Nominating Simmons Joshl Committee Barnes Barnes Members Woods Woods Annual Meeting Boston San Francisco 10/30-11/I ( ASIS ) 5/IO ( ASIS ) Program Chair Diller Chapin 1977 1978 President Ch'apin Allen Vice-President Allen Kaplan Sec-Treasurer Walker Walker Executive Diller Diller Committee Hobbs Hobbs Members Nash-Webber Bruce Editor ( AJCL ) Hays Hays Assoc Editor Heldorn Heidorn Nominating Joshi Joshi Committee Petrick Petrick Members Woods Chapin Annual Meeting Georgetown Urbana 3/16-17 ( RTLL ) 7/25-27 = TNLP Program Chair Allen Waltz 1979 1980 President Kaplan Webber Vice-President Webber Sondheimer Sec-Treasurer Walker Walker Executive Rosenschein Rosenschein Committee Hobbs Lehnert Members Bruce Bruce Editor ( AJCL ) Heidorn Heldorn Assoc Editor McCord Nominating Allen Allen Committee Petrlck Kaplan Members Chapln Chapln Annual Meeting La Jolla Philadelphia 8/11-12 ( CSS ) 6/19-22 Program Chair Sondheimer Hendrix 1981 1982 President Sondheimer Robinson Vice-President Robinson Perrault Sec-Treasurer Walker Walker Executive Rosenschein Karttunen Committee Lehnert Lehnert Members Mann Mann Editor ( AJCL ) Heldorn Petrick/Damerau Assoc Editor McCord McCord Editor ( SNLP ) Joshi Nominating Allen Sondhelmer Committee Kaplan Kaplan Members Webber Webber Annual Meeting Stanford Toronto 6/29-7/1 6/16-18~ Program Chair Perrault Bates President Vice-President Sec-Treasurer Executive Committee Members Editor ( AJCL ) Assoc Editor Editor ( SNLP ) Nominating Committee Members Annual Meeting Program Chair 1983 1984 Karttunen Mann Karttunen Joshi Sondheimer Sondheimer Webber `` Cambridge Stanford June July = COLING-84 SOME ABBREVIATIONS Publications : FS = The Finite String ( 1964-present ) MTCL = Machine Translation and Computational Linguistics ( 1965-1968 ) AJCL = AmericanJournal of Computational Linguistics ( 1974-present ) SNLP = Studies in Natural Language Processin~ ( Cambridge University Press Monograph Series , 1982-1987 ) Other organizations in conjunction ( ) with which our meeting was held or which coopted = our meeting : ACM LSA ICCL SJCC ASIS RTLL TNLP CSS COLING = Association for Computing Machinery = Linguistic Society of America International Conference on Computational Linguistics ( now called COLING ) m Spring Joint Computer Conference ( now called National Computer Conference ) American Society for Information Science Georgetown Round Table on Languages and Linguistics m Theoretical Issues on Natural Language Processing-2 = Cognitive Science Society International Conference on Computational Linguistics 91</sentence>
				<definiendum id="0">ASSOCIATION FOR MACHINE TRANSLATION AND COMPUTATIONAL LINGUISTICS</definiendum>
				<definiendum id="1">LSA</definiendum>
				<definiendum id="2">LSA</definiendum>
				<definiendum id="3">ASIS</definiendum>
				<definiendum id="4">AJCL ) Hays Hays Assoc Editor Heldorn Heidorn Nominating Joshi</definiendum>
				<definiendum id="5">String</definiendum>
				<definiens id="0">President Kuno Walker Vice-President Walker Mersel See-Treasurer Josselson Josselson Executive Satterthwalt Satterthwalt Committee Hockett Fromkln Members Pendergraft Pendergraft Editor ( FS ) Roberts Roberts Editor ( MTCL ) Yngve Yngve Assoc Editor Chapln Nominating Garvin Garvin Committee Hays Kuno Members Lieberman Lieberman Annual Meeting Atlantic City Urbana 4/21 ( SJCC ) 7/24-25 ( LSA ) Program Chair Walker Petrlck 1969 President Kay Vice-Presldent Plath Set-Treasurer Josselson Executive Satterthwalt Committee Fromkln Members Montgomery Editor ( FS ) Roberts Editor ( MTCL ) Yngve Assoc Editor Chapin Nominating Garvin Committee Kuno Members Walker Annual Meeting Boston 5113 ( sJcc ) Program Chair Fraser 1970 Plath Friedman Josselson Wall Fromkin Montgomery Roberts Yngve Chapin Kay Kuno Walker Columbus 7/22-23 ( LSA ) Wall 1971 1972 President Friedman Simmons Vice-Pres Simmons Fromkin Sec-Treas Josselson Roberts Executive Wall Wall Committee Robinson Robinson Members Montgomery Chapln Editor ( FS ) Roberts Roberts Nominating Kay Kay Committee Plath Plath Members Walker Friedman Annual Meeting Atlantic City Chapel Hill 5/17 ( SJCC ) 7/26-27 ( LSA ) Program Chair Barnes Schank Program Chair 1973 President Barnes Vice-President Woods Set-Treasurer Roberts Executive Martins Committee Robinson Members Chapin Editor ( FS ) Roberts Editor ( AJCL ) Nominating Simmons Committee Plath Members Friedman Annual Meeting</definiens>
				<definiens id="1">President Sondheimer Robinson Vice-President Robinson Perrault Sec-Treasurer Walker Walker Executive Rosenschein Karttunen Committee Lehnert Lehnert Members Mann Mann Editor ( AJCL ) Heldorn Petrick/Damerau Assoc Editor McCord McCord Editor ( SNLP ) Joshi Nominating Allen Sondhelmer Committee Kaplan Kaplan Members Webber Webber Annual Meeting Stanford Toronto 6/29-7/1 6/16-18~ Program Chair Perrault Bates President Vice-President Sec-Treasurer Executive Committee Members Editor ( AJCL ) Assoc Editor Editor ( SNLP ) Nominating Committee Members Annual Meeting Program Chair 1983 1984 Karttunen Mann Karttunen Joshi Sondheimer Sondheimer Webber `` Cambridge Stanford June July = COLING-84 SOME ABBREVIATIONS Publications : FS = The Finite</definiens>
			</definition>
</paper>

		<paper id="1014">
			<definition id="0">
				<sentence>The syntax-semantics match is realized as follows : each rule is a triple consisting of a rule name , a syntactic statement ( ~ormally a local condition on node admissibility ) , and a semantic translation , specifying how the higher-order logic representations of the daughter nodes combine to yield the correct translation for the mother .</sentence>
				<definiendum id="0">syntax-semantics match</definiendum>
				<definiens id="0">a triple consisting of a rule name , a syntactic statement ( ~ormally a local condition on node admissibility ) , and a semantic translation , specifying how the higher-order logic representations of the daughter nodes combine to yield the correct translation for the mother</definiens>
			</definition>
			<definition id="1">
				<sentence>The syntactic part of an entry consists of a syntactic feature specification ; this includes , inter alia , information about any irregular morphology the item may have , and what is known in the linguistic literature as strict subcategorization information .</sentence>
				<definiendum id="0">syntactic part of an entry</definiendum>
				<definiens id="0">consists of a syntactic feature specification ; this includes , inter alia , information about any irregular morphology the item may have , and what is known in the linguistic literature as strict subcategorization information</definiens>
			</definition>
			<definition id="2">
				<sentence>Presence in the lexical entry for an item I of the feature R ( where R is the name of a rule ) indicates that / may appear in structures admitted by R , and absence indicates that it may not .</sentence>
				<definiendum id="0">R</definiendum>
				<definiens id="0">the name of a rule ) indicates that / may appear in structures admitted by R , and absence indicates that it may not</definiens>
			</definition>
			<definition id="3">
				<sentence>75 ( LAMBDA P ( LAMBDA Q ( ( FORALL X ( P X ) ) -- &gt; ( Q x ) ) ) ) , This indicates that it denotes a function which takes as argument a set P , and returns the set of properties that are true of all members of that set ( cf. below for slightly more detailed discussion ) .</sentence>
				<definiendum id="0">LAMBDA P ( LAMBDA Q ( ( FORALL X</definiendum>
				<definiens id="0">a function which takes as argument a set P , and returns the set of properties that are true of all members of that set ( cf. below for slightly more detailed discussion )</definiens>
			</definition>
			<definition id="4">
				<sentence>A typical metarule is the passive metarule , which looks like this ( ignoring semantics ) : &lt; PAS : &lt; V ! - &gt; V NI !</sentence>
				<definiendum id="0">typical metarule</definiendum>
			</definition>
			<definition id="5">
				<sentence>The metarule has the form &lt; N : &lt; A &gt; = &gt; &lt; B &gt; &gt; , where N is a name and &lt; A &gt; and &lt; B &gt; are schemata that have rules as their instantiations when appropriate substitutions are made for the free variables .</sentence>
				<definiendum id="0">N</definiendum>
				<definiens id="0">the form &lt; N : &lt; A &gt; = &gt; &lt; B &gt; &gt;</definiens>
				<definiens id="1">rules as their instantiations when appropriate substitutions are made for the free variables</definiens>
			</definition>
			<definition id="6">
				<sentence>HIRE is a relational database with a certain amount of inferencin9 capability .</sentence>
				<definiendum id="0">HIRE</definiendum>
				<definiens id="0">a relational database with a certain amount of inferencin9 capability</definiens>
			</definition>
			<definition id="7">
				<sentence>manager relation , the sentence Anne worl &lt; s for HP will need to pick out HP with the employment.organization relation. I n order to accomodate this many-to-many mapping between a verb and particular relations in a knowledge base , the lexicon stipulates special relations that link a verb to its eventual arguments. Following Fillmore ( 1968 ) , these mediating relations are called case roles. The disambiguator narrows the case roles down to specific knowledge base relations. To take a simple example , Anne works for HP has a logical representation reducible to : ( EXISTS SIGMA ( AND ( EMPLOYMENT SIGMA ) ( AG SIGMA ANNE ) ( LOC SIGMA HP ) ) ) Here SIGMA is a variable over situations or event instantiations , s The formula may be read , `` There is an employment-situation whose Agent is Anne and whose Location is HP. '' The lexical entry for work supplies the information that its subject is an Agent and its complement a Location. The disambiguator now needs to further specify the case roles as HIRE relations. It does this by treating each atomic formula in the expression locally , using the fact that Anne is a person in order to interpret AG , and the fact that HP is an organization in order to interpret LOC. In this case , it interprets the AG role as employment.employee and the LOC role as employment.organization. The advantages of using the roles in Logical Representation , rather than going directly to predicates in a knowledge base , include ( 1 ) the ability to interpret at least some prepositional phrases , those known as adjuncts , without subcategorizing verbs specially for them , since the case role may be supplied either by a verb or a preposition. ( 2 ) the option of interpreting 'vague ' verbs such as have and give using case roles without event types. These verbs , then , become `` purely '' relational. For example , the representation of Egon gave Montague a job would be : ( EXISTS SIGMA ( AND ( ( SO EGON ) SIGMA ) ( ( POS MONTAGUE ) SIGMA ) ( EMPLOYMENT SIGMA ) ) ) Here SO 'source ' will pick out the same employment.manager relation it did in the example above ; and POS 'possession ' is the same relation as that associated with have. Here the situation-type is supplied by the translation of the noun job. It is important to realize that this representation is derived without giving the noun phrase a job any special treatment. The lexical entry for give contains the information that the subject is the source of the direct object , and the direct object the possession of the indirect object. If there were lamps in our knowledge base , the derived representation of Egon gave Montague a lamp would simply be the above formula with the predicate lamp replacing employment. The possession relation would hold between Montague and some by the recent papers of Barwise and Perry on `` situation semantics '' ; see e.c. Barwise and Perry ( 1982 ) ) . 78 lamp , and the disambiguator would retrieve whatever knowledge-base relation kept track of such matters. Two active research goals of the current project are to give all lexical entries domain independent representations , and to make all knowledge base-specific predicates and relations the exclusive province of the disambiguator. One important means to that end is case roles , which allow us a level of abstract , purely `` linguistic '' relations to mediate between logical representations and HIRE queries. Another is the use of general event types such as labor , to replace event-types specific to HIRE , such as employments. The case roles maintain a separation between the domain representation language and LR. Insofar as that separation is achieved , then absolute portability of the system , up to and including the lexicon , is an attainable goal. Absolute portability obviously has immediate practical benefits for any system that expects to handle a large fragment of English , since the effort in moving from one application to another will be limited to `` tuning '' the disambiguator to a new ontology , and adding `` specialized '' vocabulary. The actual rules governing the production of first-order logical representations make no reference to the facts of HIRE. The question remains of just how portable the current lexicon is ; the answer is that much of it is already domain independent. Quantifiers like every ( as we saw in the discussion of NP semantics ) are expressed as logical constants ; verbs like give are expressed entirely in terms of the case relations that hold among their arguments. Verbs like work can be abstracted away from the domain by a simple extension. The obvious goal is to try to give domain independent representations to a core vocabulary of English that could be used in a variety of application domains. We shall now give a slightly more detailed illustration of how the syntax and compositional semantics rules work. We are still simplifying considerably , since we have selected an example where rote frames are not involved , and we are not employing features on nodes. Here we have the grammar of a trivial subset of English : &lt; $ 1 : S - &gt; NP VP : ( NP Vp ) &gt; '' &lt; NPI : NP - &gt; DET N : ( DET N ) &gt; &lt; VPI : VP - &gt; V NP : iV NP ) &gt; &lt; VP2 : VP - &gt; V A : A &gt; Suppose that the lexicon associated with the above rules is : &lt; every : DET : ( LAMBDA P ( LAMBDA Q ( FORALL X ( ( P X ) IMPLIES ( Q X ) ) ) ) ) &gt; &lt; applicant : N : APPLICANT &gt; &lt; interviewed : V\ [ ( RULE VP1 ) \ ] : INTERVIEW &gt; &lt; Bill : NP : ( LAMBDA P ( P BILL ) ) &gt; &lt; is : V\ [ ( RULE MP2 ) \ ] : ( BE ) &gt; &lt; competent : A : ( LAMBDA Y ( EXPERT.LEVEL HIGH Y ) ) &gt; The syntax of a lexical entry is &lt; L : C : T &gt; , where L is the spelling of the item , C is its grammatical category and feature specification ( if other than the default set ) and T is its translation into LR .</sentence>
				<definiendum id="0">disambiguator</definiendum>
				<definiendum id="1">HP</definiendum>
				<definiendum id="2">L</definiendum>
				<definiens id="0">the sentence Anne worl &lt; s for HP will need to pick out HP with the employment.organization relation. I n order to accomodate this many-to-many mapping between a verb and particular relations in a knowledge base , the lexicon stipulates special relations that link a verb to its eventual arguments. Following Fillmore</definiens>
				<definiens id="1">narrows the case roles down to specific knowledge base relations. To take a simple example , Anne works for HP has a logical representation reducible to : ( EXISTS SIGMA ( AND ( EMPLOYMENT SIGMA ) ( AG SIGMA ANNE ) ( LOC SIGMA HP ) ) ) Here SIGMA is a variable over situations or event instantiations , s The formula may be read , `` There is an employment-situation whose Agent is Anne and whose Location is HP. '' The lexical entry for work supplies the information that its subject is an Agent and its complement a Location. The disambiguator now needs to further specify the case roles as HIRE relations. It does this by treating each atomic formula in the expression locally , using the fact that Anne is a person in order to interpret AG</definiens>
				<definiens id="2">advantages of using the roles in Logical Representation , rather than going directly to predicates in a knowledge base , include ( 1 ) the ability to interpret at least some prepositional phrases , those known as adjuncts , without subcategorizing verbs specially for them , since the case role may be supplied either by a verb or a preposition. ( 2 ) the option of interpreting 'vague ' verbs such as have and give using case roles without event types. These verbs , then , become `` purely '' relational. For example , the representation of Egon gave Montague a job would be : ( EXISTS SIGMA ( AND ( ( SO EGON ) SIGMA ) ( ( POS MONTAGUE ) SIGMA ) ( EMPLOYMENT SIGMA ) ) ) Here SO 'source ' will pick out the same employment.manager relation it did in the example above</definiens>
				<definiens id="3">important to realize that this representation is derived without giving the noun phrase a job any special treatment. The lexical entry for give contains the information that the subject is the source of the direct object , and the direct object the possession of the indirect object. If there were lamps in our knowledge base , the derived representation of Egon gave Montague a lamp would simply be the above formula with the predicate lamp replacing employment. The possession relation would hold between Montague and some by the recent papers of Barwise and Perry on `` situation semantics '' ; see e.c. Barwise and Perry ( 1982 ) ) . 78 lamp , and the disambiguator would retrieve whatever knowledge-base relation kept track of such matters. Two active research goals of the current project are to give all lexical entries domain independent representations , and to make all knowledge base-specific predicates and relations the exclusive province of the disambiguator. One important means to that end is case roles , which allow us a level of abstract , purely `` linguistic '' relations to mediate between logical representations and HIRE queries. Another is the use of general event types such as labor , to replace event-types specific to HIRE , such as employments. The case roles maintain a separation between the domain representation language and LR. Insofar as that separation is achieved , then absolute portability of the system</definiens>
				<definiens id="4">an attainable goal. Absolute portability obviously has immediate practical benefits for any system that expects to handle a large fragment of English , since the effort in moving from one application to another will be limited to `` tuning '' the disambiguator to a new ontology , and adding `` specialized '' vocabulary. The actual rules governing the production of first-order logical representations make no reference to the facts of HIRE. The question remains of just how portable the current lexicon is ; the answer is that much of it is already domain independent. Quantifiers like every ( as we saw in the discussion of NP semantics ) are expressed as logical constants ; verbs like give are expressed entirely in terms of the case relations that hold among their arguments. Verbs like work can be abstracted away from the domain by a simple extension. The obvious goal is to try to give domain independent representations to a core vocabulary of English that could be used in a variety of application domains. We shall now give a slightly more detailed illustration of how the syntax and compositional semantics rules work. We are still simplifying considerably</definiens>
				<definiens id="5">a trivial subset of English : &lt; $ 1 : S - &gt; NP VP : ( NP Vp ) &gt; '' &lt; NPI : NP - &gt; DET N : ( DET N ) &gt; &lt; VPI : VP - &gt; V NP : iV NP ) &gt; &lt; VP2 : VP - &gt; V A : A &gt; Suppose that the lexicon associated with the above rules is : &lt; every : DET : ( LAMBDA P ( LAMBDA Q ( FORALL X ( ( P X ) IMPLIES ( Q X ) ) ) ) ) &gt; &lt; applicant : N : APPLICANT &gt; &lt; interviewed : V\ [ ( RULE VP1 ) \ ] : INTERVIEW &gt; &lt; Bill : NP : ( LAMBDA P ( P BILL ) ) &gt; &lt; is : V\ [ ( RULE MP2 ) \ ] : ( BE ) &gt; &lt; competent : A : ( LAMBDA Y ( EXPERT.LEVEL HIGH Y ) ) &gt; The syntax of a lexical entry is &lt; L : C : T &gt; , where</definiens>
				<definiens id="6">the spelling of the item</definiens>
			</definition>
			<definition id="8">
				<sentence>It represents a function from properties to functions from properties to truth values , so when applied to applicant it yields a constituent , namely every applicant , which has one of the property slots filled , and represents a function from properties to truth-values ; it is : ( LAMBDA P ( FORALL X ( ( APPLICANT X ) IMPLIES ( P X ) ) ) ) This function can now be applied to the function denoted by competent , i.e. ( LAMBDA Y ( EXPERT .</sentence>
				<definiendum id="0">LAMBDA Y</definiendum>
				<definiens id="0">a function from properties to functions from properties to truth values , so when applied to applicant it yields a constituent</definiens>
			</definition>
</paper>

		<paper id="1003">
			<definition id="0">
				<sentence>A dynamic model is a `` good enough '' approximation to an infinite model when it contains the finite subset of information that is needed to determine the meanings of the sentences actually presented to the system .</sentence>
				<definiendum id="0">dynamic model</definiendum>
				<definiens id="0">needed to determine the meanings of the sentences actually presented to the system</definiens>
			</definition>
</paper>

	</volume>
